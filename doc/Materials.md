# Полезная информация

#### Что это?

Тут я собрал информацию, которая была для меня полезной, во время решения данной лабораторной работы.

В процессе решения возникают вопросы, в которых необходимо разобраться. Информацию я нахожу в интернете, или спрашиваю у нейросетей.

В случае, если у меня возникает какой-то вопрос, найденную информацию я сохраняю сюда.

Это помогает **глубже** разобраться в вопросе и сделать для себя материал, который поможет понять и запомнить важные моменты и понятия.

---

# Что такое разделяемая память (Shared Memory)?

Представим, что у каждого процесса есть свой собственный, изолированный "блокнот" с данными (его адресное пространство). Ни один процесс не может заглянуть в блокнот другого. Это сделано для безопасности и стабильности системы.

**Разделяемая память (Shared Memory, SHM)** — это специальный механизм, который позволяет операционной системе выделить один "общий блокнот" и "вклеить" его страницы в адресные пространства нескольких процессов.

<img title="" src="https://media.geeksforgeeks.org/wp-content/uploads/20240710145648/Screenshot-2024-07-10-131723.png" alt="" data-align="center">

Для процессов этот "общий блокнот" выглядит как обычный участок их собственной памяти. Они могут читать из него и писать в него так же, как в обычный массив. Но как только один процесс что-то записывает в эту область, изменения **мгновенно** становятся видны всем остальным процессам, у которых эта память подключена.

Это самый быстрый способ обмена данными, потому что данные не копируются из одного процесса в другой (как в pipe), а лежат в одном общем месте.

---

# Системные вызовы для работы с разделяемой памятью (POSIX)

Для работы с SHM в Linux-подобных системах обычно используются системные вызовы стандарта POSIX. Вот основные из них:

1. `shm_open()`: Это "создатель" нашего общего блокнота. Функция создает или открывает объект разделяемой памяти. Взамен вы получаете файловый дескриптор, похожий на тот, что вы получаете при работе с файлами.
   
   Его работа аналогична системному вызову `open()` для обычных файлов.
   
   Функция принимает три параметра: 
   
   1. **`name`**: Указатель на строку, завершающуюся нулевым символом, которая служит именем объекта разделяемой памяти. Для переносимости (портативности) имя должно начинаться с символа косой черты `/`, за которым следует один или более символов (без дополнительных косых черт).
   
   2. **`oflag`**: Битовая маска, определяющая режим открытия объекта (аналогично `open()`). Обязательно должен присутствовать один из следующих флагов:
      
      - `O_RDONLY`: Открытие только для чтения.
      - `O_RDWR`: Открытие для чтения и записи.
      
      Также можно использовать дополнительные флаги, объединяя их через оператор битового ИЛИ (`|`):
      
      - `O_CREAT`: Создать объект разделяемой памяти, если он не существует.
      - `O_EXCL`: Используется вместе с `O_CREAT`. Если объект с таким именем уже существует, `shm_open()` вернет ошибку, а `errno` будет установлено в `EEXIST`.
      - `O_TRUNC`: Если объект уже существует, он будет усечен до длины 0 байтов.
   
   3. **`mode`**: Разрешения доступа (права доступа) к объекту разделяемой памяти, аналогичные правам доступа к файлам в Unix (например, `S_IRUSR` для чтения владельцем, `S_IWUSR` для записи владельцем). Этот параметр используется только в том случае, если в `oflag` указан флаг `O_CREAT`.
      
      | Константа | Описание права доступа (POSIX)                    | Эквивалент в umask/chmod |
      | --------- | ------------------------------------------------- | ------------------------ |
      | `S_IRUSR` | Право на **чтение** для **владельца** (User)      | `u+r`                    |
      | `S_IWUSR` | Право на **запись** для **владельца** (User)      | `u+w`                    |
      | `S_IXUSR` | Право на **выполнение** для **владельца** (User)  | `u+x`                    |
      | `S_IRWXU` | Чтение, запись, выполнение для **владельца**      | `u+rwx`                  |
      | `S_IRGRP` | Право на **чтение** для **группы** (Group)        | `g+r`                    |
      | `S_IWGRP` | Право на **запись** для **группы** (Group)        | `g+w`                    |
      | `S_IXGRP` | Право на **выполнение** для **группы** (Group)    | `g+x`                    |
      | `S_IRWXG` | Чтение, запись, выполнение для **группы**         | `g+rwx`                  |
      | `S_IROTH` | Право на **чтение** для **остальных** (Other)     | `o+r`                    |
      | `S_IWOTH` | Право на **запись** для **остальных** (Other)     | `o+w`                    |
      | `S_IXOTH` | Право на **выполнение** для **остальных** (Other) | `o+x`                    |
      | `S_IRWXO` | Чтение, запись, выполнение для **остальных**      | `o+rwx`                  |
   
   4. **При ошибке**: Функция возвращает **-1** и устанавливает глобальную переменную `errno` для указания типа ошибки (например, `EACCES` при отказе в доступе, `ENOENT` если объект не существует без флага `O_CREAT`)
   - `shm_open("my_shm", O_CREAT | O_RDWR, S_IWUSR);`

2. `ftruncate()`: После создания объекта SHM он имеет размер 0. Этой функцией мы "задаем размер" общему блокноту.
   
   Основная задача `ftruncate()` — гарантировать, что объект имеет определенную длину в байтах.
   
   В контексте работы с разделяемой памятью (после вызова `shm_open()`), этот вызов **критически важен**, так как вновь созданный объект разделяемой памяти изначально имеет размер 0 байтов. Прежде чем вы сможете отобразить его в память процесса с помощью `mmap()` и начать с ним работать, вы должны задать ему нужный размер с помощью `ftruncate()`.
   
   ```c
   #include <unistd.h>
   #include <sys/types.h>
   
   int ftruncate(int fd, off_t length);
   ```
   
   - `ftruncate(fd, size);`
     
     Параметры:
     1. **`fd` (file descriptor):** Целочисленный файловый дескриптор, который был ранее получен в результате успешного вызова `open()`, `shm_open()` или подобной функции.
     2. **`length` (длина):** Новая длина объекта в байтах (тип `off_t`).
     
     **Если новая длина (`length`) меньше текущего размера объекта:** Данные в конце объекта обрезаются и становятся недоступными.
   - **Если новая длина (`length`) больше текущего размера объекта:** Размер объекта увеличивается. Область, добавленная в конец (пространство между старым концом и новым концом), заполняется нулевыми байтами (null bytes, `\0`).
   
   Возвращаемое значение
   
   - **0:** В случае успешного выполнения.
   - **-1:** В случае ошибки. При этом устанавливается соответствующее значение в глобальной переменной `errno` (например, `EBADF` если дескриптор недействителен, или `EFBIG` если размер превышает максимальный лимит файловой системы).

3. `mmap()`: Это ключевая функция. Она берет созданный и настроенный объект SHM и **отображает (подключает)** его в адресное пространство нашего процесса. Взамен мы получаем указатель, с которым можно работать как с обычным массивом в C.
   
   ```c
   #include <sys/mman.h>
   #include <sys/stat.h> /* для констант режима (mode) */
   #include <fcntl.h>    /* для констант флагов (flags) */
   #include <unistd.h>   /* для off_t */
   
   void *mmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset);
   ```
   
   Параметры:
   
   Функция принимает шесть аргументов:
   
   1. **`addr` (address):** Предпочтительный адрес в виртуальном адресном пространстве процесса, куда будет отображен объект.
      
      - Чаще всего используется значение **`NULL`**. В этом случае ядро операционной системы автоматически выбирает подходящий, неиспользуемый адрес страницы памяти.
   
   2. **`length` (длина):** Количество байтов, которое нужно отобразить, начиная от заданного смещения (`offset`). Размер должен быть ненулевым.
   
   3. **`prot` (protection):** Битовая маска, определяющая желаемые права доступа к отображенной области памяти. Обязательно должен быть указан как минимум один из флагов:
      
      - `PROT_NONE`: Доступ запрещен.
      - `PROT_READ`: Страницы доступны для чтения.
      - `PROT_WRITE`: Страницы доступны для записи (используется для изменения файла/памяти).
      - `PROT_EXEC`: Страницы доступны для выполнения (как код).
      
      Эти флаги объединяются оператором `|` (например, `PROT_READ | PROT_WRITE`).
   
   4. **`flags` (флаги отображения):** Определяют тип отображения и поведение при изменениях. Обязательно должен присутствовать один из следующих флагов:
      
      - `MAP_SHARED`: Изменения, внесенные в отображенную память, **видны другим процессам**, которые отобразили тот же объект (и записываются обратно в файл/shm объект). Это ключевой флаг для **разделяемой памяти**.
      - `MAP_PRIVATE`: Изменения, внесенные в память, **не видны другим процессам** и не записываются обратно в исходный файл (создается копия при записи).
      
      Также часто используется дополнительный флаг `MAP_FIXED` (используется редко, требует точного `addr`).
   
   5. **`fd` (file descriptor):** Файловый дескриптор открытого объекта, который мы хотим отобразить (например, результат вызова `shm_open()` или `open()`).
   
   6. **`offset` (смещение):** Смещение в байтах от начала файла или объекта, откуда начнется отображение. Должно быть выровнено по границе страницы памяти (обычно кратно размеру страницы, который можно получить через `getpagesize()` или `sysconf(_SC_PAGESIZE)`). Обычно используется `0`.
   
   Возвращаемое значение
   
   - **При успешном выполнении:** Функция возвращает **указатель на тип `void*`**, который указывает на начало отображенной области памяти в адресном пространстве процесса. Этот указатель нужно привести к нужному типу (например, `char*`, `int*`, `struct*`).
   - **При ошибке:** Функция возвращает специальное значение **`MAP_FAILED`** (которое определено как `(void *) -1`). При этом устанавливается глобальная переменная `errno` для указания типа ошибки.
   
   - `mmap(NULL, size, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);`
   
   ```c
   #include <sys/mman.h>
   #include <fcntl.h>
   #include <unistd.h>
   #include <stdio.h>
   
   int main() {
       // ... (предполагается, что shm_open и ftruncate выполнены успешно)
       int fd = shm_open("/my_shm", O_RDWR, 0666);
       ftruncate(fd, 4096);
   
       // Отображаем объект разделяемой памяти в адресное пространство процесса
       void *ptr = mmap(NULL,          // addr: Ядро само выберет адрес
                        4096,          // length: Размер отображения
                        PROT_READ | PROT_WRITE, // prot: Права чтения/записи
                        MAP_SHARED,    // flags: Разделяемая память
                        fd,            // fd: Файловый дескриптор
                        0);            // offset: Начиная с начала объекта
   
       if (ptr == MAP_FAILED) {
           perror("mmap failed");
           return 1;
       }
   
       // Теперь можно использовать ptr как обычный указатель:
       sprintf((char*)ptr, "Привет, мир!");
   
       // Не забываем освобождать ресурсы:
       munmap(ptr, 4096);      // Удаляем отображение памяти
       close(fd);              // Закрываем файловый дескриптор
       shm_unlink("/my_shm");  // Удаляем объект разделяемой памяти из системы
   
       return 0;
   }
   ```

4. `munmap()`: Когда работа с памятью завершена, ее нужно "отключить" от процесса.
   
   Это обратная операция к системному вызову `mmap()`.
   
   Когда мы вызываем `mmap()`, мы создаём связь между файлом/объектом разделяемой памяти и диапазоном адресов в процессе. `munmap()` разрывает эту связь.
   
   Основные последствия вызова `munmap()`:
   
   1. **Память становится недоступной:** После успешного вызова `munmap()` попытка доступа к адресам, которые ранее занимала отображенная область (начиная с указателя, возвращенного `mmap()`), приведет к ошибке сегментации (Segmentation Fault, `SIGSEGV`).
   2. **Синхронизация данных (для `MAP_SHARED`):** Если область была отображена с флагом `MAP_SHARED`, любые изменения, внесенные в память до вызова `munmap()`, гарантированно записываются обратно в базовый объект разделяемой памяти или файл.
   3. **Освобождение ресурсов:** Часть виртуального адресного пространства процесса освобождается и может быть использована для других целей.
   
   Параметры
   
   1. **`addr` (address):** Указатель на **начальный адрес** отображенной области памяти. Это должен быть тот самый указатель, который был возвращен системным вызовом `mmap()` (или адрес, кратный размеру страницы памяти внутри отображенной области).
   2. **`length` (длина):** Длина отображенной области в байтах. Она должна точно совпадать с тем значением `length`, которое использовалось при вызове `mmap()`.
   - `munmap(ptr, size);`

5. `shm_unlink()`: Когда "общий блокнот" больше не нужен ни одному процессу, его нужно удалить из системы, чтобы не утекала память.
   
   - `shm_unlink("my_shm") = 0`
     
     Это сам системный вызов с его аргументом (именем объекта).
     
     **`= 0`**: Это **возвращаемое значение** системного вызова.
     - `0` означает **успех** (объект был успешно удален или помечен для удаления).
     
     - Если бы объект не существовал, `strace` мог бы показать ошибку, например:
       
       ```bash
       shm_unlink("non_existent_shm") = -1 ENOENT (No such file or directory)
       ```

### Разделяемая память vs. Каналы (Pipes)

| Критерий             | Каналы (Pipes)                                                                                                                                       | Разделяемая память (Shared Memory)                                                                                                                                                                      |
| -------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **Скорость**         | Медленнее. Данные копируются из адресного пространства одного процесса в ядро, а затем из ядра в адресное пространство другого.                      | **Самый быстрый IPC**. Данные не копируются. Все процессы работают с одной и той же областью памяти.                                                                                                    |
| **Синхронизация**    | **Встроена**. Pipe — это по сути очередь. Если один процесс пишет, другой читает. Ядро ОС само заботится о том, чтобы процессы не мешали друг другу. | **Отсутствует!** Это самый большой недостаток и главная сложность. Если два процесса попытаются записать данные одновременно, получится "каша" (состояние гонки). Нужны внешние средства синхронизации. |
| **Структура данных** | Поток байт (stream). Неструктурированный.                                                                                                            | Любая структура. Вы можете разместить в общей памяти `struct`, массив, что угодно. Это очень гибко.                                                                                                     |
| **Направление**      | Однонаправленный (Unidirectional). Для двусторонней связи нужно два канала.                                                                          | Двунаправленный по своей природе. Все могут и читать, и писать (если разрешено).                                                                                                                        |
| **Сложность**        | Проще в использовании из-за встроенной синхронизации.                                                                                                | Сложнее, так как требует ручного управления синхронизацией (семафоры, мьютексы).                                                                                                                        |

# Важнейший аспект: Синхронизация

Как было сказано выше, с SHM возникает проблема: как процессам координировать свои действия?

- `Child1` должен начать работу только **после** того, как `Parent` записал данные.
- `Child2` должен начать работу только **после** того, как `Child1` закончил.
- `Parent` должен вывести результат только **после** того, как `Child2` закончил.

Эту координацию обеспечивают **семафоры** или **мьютексы**. Для нашей задачи семафоры подходят идеально. Семафор — это, по сути, счетчик, который процессы могут атомарно (неделимо) увеличивать или уменьшать, чтобы сигнализировать друг другу.
